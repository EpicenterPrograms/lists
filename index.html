<!doctype html>
<html>
	<head>
		<title>
			Lists
		</title>
		<base target="_blank">
		<link rel="icon" href="favicon.ico">
		<script src="https://www.gstatic.com/firebasejs/4.6.1/firebase.js"></script>
		<script src="https://www.gstatic.com/firebasejs/4.6.1/firebase-firestore.js"></script>
		<script src="https://epicenterprograms.github.io/standards/behavior/firebaseinit.js"></script>
		<script src="https://epicenterprograms.github.io/standards/behavior/general.js"></script>
		<script src="https://epicenterprograms.github.io/standards/behavior/storage.js"></script>
		<!--
		<script src="file:///C:/Users/rtben/Documents/GitHub/standards/behavior/general.js"></script>
		<script src="file:///C:/Users/rtben/Documents/GitHub/standards/behavior/storage.js"></script>
		-->
		<script>
			var S = Standards.general;
			var M = Standards.storage;
			M.session.defaultLocation = "/lists/Default/items";  //// "lists/items" "lists/default/items"
			M.local.defaultLocation = "/lists/Default/items";  //// "lists/items" "lists/default/items"
			M.server.defaultLocation = "/lists";  //// "lists/default/items"

			var currentList = "Default";
			var itemSet = {};
			var itemNumber = 1;
			var now = new Date();
			var week = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
			var dayThreshold = 7;
			var mergeData = false;
			var deleteData = false;
			var advancedSettingsSection;
			var advancedEditorSection;
			var pastDueNumber = 0;
			var dueTodayNumber = 0;
			var storagePlace = "local";
			var noisemaker;
			var labelList = [];
			var itemBeingEdited = "";
			var recyclingBin = {};

			var sampleList = [
				{
					description: "finish my math homework",
					elaboration: "chapter 7, activity 5, questions 5-20",
					importance: 4,
					recurrence: "weekly",
					time: "monday wednesday friday~11:59 pm",
					difficulty: 4,
					lastFinished: now.getTime(),
					done: false,
					lastUpdated: now.getTime()
				},
				{
					description: "go to work",
					importance: 4,
					recurrence: "weekly",
					time: "monday tuesday wednesday thursday friday~4:00 pm",
					lastFinished: now.getTime(),
					done: false,
					lastUpdated: now.getTime()
				},
				{
					description: "oil the door hinge",
					importance: 1,
					recurrence: "indefinite",
					time: now.getTime() + 86400000 + "~",
					difficulty: 2,
					lastFinished: now.getTime() - 172800000,
					done: false,
					lastUpdated: now.getTime()
				},
				{
					description: "brush my teeth",
					importance: 3,
					recurrence: "daily",
					time: "~10:30 pm",
					difficulty: 1,
					lastFinished: now.getTime(),
					done: false,
					labels: ["sanitary"],
					lastUpdated: now.getTime()
				},
				{
					description: "cut the grass",
					importance: 2,
					recurrence: "indefinite",
					time: now.getTime() + 700000000 + "~",
					difficulty: 4,
					lastFinished: now.getTime(),
					done: false,
					lastUpdated: now.getTime()
				},
				{
					description: "go to Joe's party",
					importance: 2,
					recurrence: "once",
					time: function () {
						let time = new Date(now.getTime() + 345600000);
						return (time.getMonth()+1) + "/" + time.getDate() + "/" + time.getFullYear() + "~8:00 pm";
					}(),
					lastFinished: now.getTime(),
					done: false,
					labels: ["fun"],
					lastUpdated: now.getTime()
				},
				{
					description: "take out the trash",
					importance: 3,
					recurrence: "weekly",
					time: "friday~7:00 pm",
					lastFinished: now.getTime(),
					done: true,
					labels: ["sanitary"],
					lastUpdated: now.getTime()
				},
				{
					description: "have game night",
					elaboration: "play hangman, charades, and Apples to Apples",
					importance: 2,
					recurrence: "monthly",
					time: "10~8:00 pm",
					lastFinished: now.getTime(),
					done: false,
					labels: ["fun"],
					lastUpdated: now.getTime()
				},
				{
					description: "sign up for the charity event",
					elaboration: "5 Giving Way, room 213",
					importance: 2,
					recurrence: "once",
					time: function () {
						let time = new Date(now.getTime() - 86400000);
						return (time.getMonth() + 1) + "/" + time.getDate() + "/" + time.getFullYear() + "~5:00 pm";
					}(),
					lastFinished: now.getTime()-172800000,
					done: false,
					lastUpdated: now.getTime()
				},
				{
					description: "find my keys",
					elaboration: "check under the couch",
					importance: 5,
					recurrence: "indefinite",
					time: now.getTime() + "~",
					difficulty: 5,
					lastFinished: now.getTime(),
					done: true,
					lastUpdated: now.getTime()
				},
				{
					description: "have breakfast with Sally",
					importance: 3,
					recurrence: "once",
					time: (function () {
						let year = (now.getMonth()>10 ? now.getFullYear()+1 : now.getFullYear());
						let month = ((now.getMonth()>10 ? 0 : now.getMonth()+1)+1);
						let day = (now.getDate()+1);
						let time = "~8:00 am";
						if (String(month).length == 1) {
							month = "0" + month;
						}
						if (String(day).length == 1) {
							day = "0" + day;
						}
						return year + " " + month + " " + day + time;
					})(),
					lastFinished: now.getTime(),
					done: false,
					labels: ["fun"],
					lastUpdated: now.getTime()
				},
				{
					description: "clean my room",
					importance: 2,
					recurrence: "continual",
					time: now.getTime() + 2200000000 + "~",
					difficulty: 5,
					lastFinished: now.getTime() - 1000000000,
					done: false,
					labels: [],
					lastUpdated: now.getTime()
				},
				{
					description: "go jogging",
					importance: 5,
					recurrence: "continual",
					time: now.getTime() + "~",
					difficulty: 3,
					lastFinished: now.getTime() - 200000000,
					done: false,
					labels: [],
					lastUpdated: now.getTime()
				}
			];



			function encode(text) {
				return encodeURIComponent(text.replace(/</g, "&lt;").replace(/>/g, "&gt;")).replace(/\*/g, "%2A");
			}




			function makeDynamicItem(description, item) {
				/**
				adds a dynamic list item to itemSet
				*/
				
				// makes a Date object for the due date (assigned to "then")
				let importance = item.importance;
				let date = item.time;
				let recurrence = item.recurrence;
				let lastFinished = item.lastFinished;
				let done = item.done;
				let labels = item.labels;
				var originalDate = date;
				var then = date.split("~")[0].trim();
				var time = " " + date.split("~")[1].trim();
				function combine(array) {
					return new Date(array.join(" ") + time);
				}
				let beginning = new Date(Number(lastFinished));
				switch (recurrence) {  // sets the exact time of the (next) event
					case "continual":
					case "indefinite":
						then = new Date(Number(then));  // Number() is needed because "then" is a string
						// "date" can't also be set here because it causes the due time displayed to always be what it was originally
						break;
					case "once":
						if (then.includes("/")) {  ////
							then = new Date([].concat(then.split("/")[2], then.split("/").slice(0, 2)).join(" ") + time);
							date = then.getMonth() + 1 + "/" + then.getDate() + "/" + then.getFullYear() + time;
						} else {
							then = new Date(then + time);
							date = then.getMonth() + 1 + "/" + then.getDate() + "/" + then.getFullYear() + time;
						}
						break;
					case "monthly":
						if (beginning.getDate() == then) {
							if (beginning.getTime() <= combine([beginning.getFullYear(), beginning.getMonth()+1, then]).getTime()) {
								then = combine([beginning.getFullYear(), beginning.getMonth()+1, then]);
							} else {
								if (beginning.getMonth() + 2 <= 12) {
									then = combine([beginning.getFullYear(), beginning.getMonth()+2, then]);
								} else {
									then = combine([beginning.getFullYear()+1, 1, then]);
								}
							}
						} else if (beginning.getDate() < then) {
							then = new Date(beginning.getTime() + (then-beginning.getDate())*86400000);
						} else {
							if (beginning.getMonth() + 2 <= 12) {
								then = combine([beginning.getFullYear(), beginning.getMonth()+2, then]);
							} else {
								then = combine([beginning.getFullYear()+1, 1, then]);
							}
						}
						date = then.getMonth()+1 + "/" + then.getDate() + "/" + then.getFullYear() + time;
						break;
					case "weekly":
						let closest = Infinity;
						then.split(" ").forEach(function(weekday) {
							let number = week.indexOf(weekday);
							if (beginning.getDay() > number) {
								number = 7 + number - beginning.getDay();
							} else {
								number -= beginning.getDay();
							}
							if (number < closest) {
								closest = number;
							}
						});
						closest += beginning.getDay();
						if (closest > 6) {
							closest -= 7;
						}
						if (beginning.getDay() == closest) {
							if (beginning.getTime() <= combine([beginning.getFullYear(), beginning.getMonth()+1, beginning.getDate()]).getTime()) {
								then = combine([beginning.getFullYear(), beginning.getMonth()+1, beginning.getDate()]);
							} else {
								closest = Infinity;
								then.split(" ").forEach(function(weekday) {
									let number = week.indexOf(weekday);
									if (beginning.getDay() + 1 > number) {
										number = 6 + number - beginning.getDay();
									} else {
										number -= beginning.getDay() + 1;
									}
									if (number < closest) {
										closest = number;
									}
								});
								closest += beginning.getDay() + 1;
								if (closest > 6) {
									closest -= 7;
								}
								if (beginning.getDay() < closest) {
									then = new Date(beginning.getTime() + (closest-beginning.getDay())*86400000);
									then = combine([then.getFullYear(), then.getMonth()+1, then.getDate()]);
								} else {
									then = new Date(beginning.getTime() + (7+closest-beginning.getDay())*86400000);
									then = combine([then.getFullYear(), then.getMonth()+1, then.getDate()]);
								}
							}
						} else if (beginning.getDay() < closest) {
							then = new Date(beginning.getTime() + (closest-beginning.getDay())*86400000);
							then = combine([then.getFullYear(), then.getMonth()+1, then.getDate()]);
						} else {
							then = new Date(beginning.getTime() + (7+closest-beginning.getDay())*86400000);
							then = combine([then.getFullYear(), then.getMonth()+1, then.getDate()]);
						}
						date = then.getMonth()+1 + "/" + then.getDate() + "/" + then.getFullYear() + time;
						break;
					case "daily":
						then = combine([beginning.getFullYear(), beginning.getMonth()+1, beginning.getDate()]);
						if (beginning.getTime() > then.getTime()) {
							then = new Date(then.getTime()+86400000);
						}
						date = then.getMonth()+1 + "/" + then.getDate() + "/" + then.getFullYear() + time;
						break;
				}
				
				// sets the urgency of the item
				now = new Date();
				if (recurrence == "indefinite" || recurrence == "continual") {
					date = then.getTime() - now.getTime();
					if (date <= 0) {
						date = "Immediately";
					} else if (date <= 250000000) {
						date = "Soon";
					} else if (date <= 700000000) {
						date = "Later";
					} else if (date <= 1600000000) {
						date = "In a while";
					} else {
						date = "At some point";
					}
					var urgency = (then.getTime()-now.getTime())/1000;
					if (urgency < 54000) {  // Negative numbers will put it at the end, not the top.
						urgency = 54000;  // This causes indefinite items to effectively never be any closer than 15 hours away.
					}
					urgency = Math.round(urgency * (10-importance));
				} else if (recurrence == "daily") {
					var urgency = Math.round(Math.abs(then.getTime()-now.getTime())/100*(10-importance));
				} else {
					var urgency = Math.round(Math.abs(then.getTime()-now.getTime())/1000*(10-importance));
				}
				if (item.difficulty) {
					urgency = Math.round(urgency * ((6 - item.difficulty) / 2));
				} else {
					urgency = Math.round(urgency * 1.5);
				}
				
				// creates the HTML objects to be displayed
				let checkbox = document.createElement("input");
				checkbox.type = "checkbox";
				checkbox.id = "item" + itemNumber;
				itemNumber++;
				let label = document.createElement("span");
				if (recurrence == "indefinite" || recurrence == "continual") {
					label.title = "Due: {0}\nImportance: {1}".format(date, importance);
				} else {
					if (then.getTime() - now.getTime() < 86400000) {
						label.title = "Due:{0}\nImportance: {1}".format(time, importance);
					} else if (then.getTime() - now.getTime() < 518400000) {
						label.title = "Due: {0}\nImportance: {1}".format(["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][then.getDay()]+time, importance);
					} else {
						label.title = "Due: {0}\nImportance: {1}".format(["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][then.getDay()]+", "+date, importance);
					}
				}
				label.innerHTML = decodeURIComponent(description);
				
				// sets label highlighting
				if (then.getTime() >= now.getTime() || recurrence == "indefinite" || recurrence == "continual") {
					let later;
					if (recurrence == "indefinite") {
						if (then.getTime() <= now.getTime()) {
							label.style.fontWeight = "bold";
							if (importance == 5) {
								label.style.textDecoration = "underline";
							} else if (importance == 4) {
								label.style.WebkitTextDecorationStyle = "dotted";  // for Safari
								label.style.textDecoration = "underline dotted";
							}
							label.innerHTML = "<mark style='background:#00ff00'>" + label.innerHTML + "</mark>";
						} else if (then.getTime() - now.getTime() < (then.getTime()-lastFinished) / 3) {
							label.innerHTML = "<mark style='background:#88ff88'>" + label.innerHTML + "</mark>";
						}
					} else if (recurrence == "continual") {
						if (then.getTime() <= now.getTime()) {
							label.style.fontWeight = "bold";
							label.innerHTML = "<mark style='background:#00aaff'>" + label.innerHTML + "</mark>";
						} else if (then.getTime() - now.getTime() < (then.getTime()-lastFinished) / 3) {
							label.innerHTML = "<mark style='background:#88aaff'>" + label.innerHTML + "</mark>";
						}
					} else if (recurrence == "daily") {
						if (then.getTime() - now.getTime() < 10800000) {  // if it's closer than 3 hours away
							label.style.fontWeight = "bold";
							if (importance == 5) {
								label.style.textDecoration = "underline";
							} else if (importance == 4) {
								label.style.WebkitTextDecorationStyle = "dotted";
								label.style.textDecoration = "underline dotted";
							}
							label.innerHTML = "<mark style='background:#ff00ff'>" + label.innerHTML + "</mark>";
						} else if (then.getTime() - now.getTime() < 21600000) {  // if it's closer than 6 hours away
							label.innerHTML = "<mark style='background:#ff88ff'>" + label.innerHTML + "</mark>";
						}
					} else {
						////////////////////////////////////////// setting the due-today number should be done somewhere around here
						if (now.getHours() < dayThreshold) {  // if the current time is before the day threshold (defaults to 8:00am)
							later = new Date(new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime() + 86400000);
						} else {
							later = new Date(new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime() + 172800000);
						}
						if (then.getTime() < later.getTime()) {
							label.style.fontWeight = "bold";
							if (importance == 5) {
								label.style.textDecoration = "underline";
							} else if (importance == 4) {
								label.style.WebkitTextDecorationStyle = "dotted";
								label.style.textDecoration = "underline dotted";
							}
							label.innerHTML = "<mark>" + label.innerHTML + "</mark>";
						} else if (then.getTime() < later.getTime() + 86400000) {
							label.innerHTML = "<mark style='background:#ffff88'>" + label.innerHTML + "</mark>";
						}
					}
				} else {
					label.style.fontWeight = "bold";
					if (importance == 5) {
						label.style.textDecoration = "underline solid red";
					} else if (importance == 4) {
						label.style.WebkitTextDecorationStyle = "dotted";
						label.style.textDecoration = "underline dotted red";
					}
					label.style.color = "red";
					label.title = "Past due";
					pastDueNumber++;
				}
				
				// puts the elements into a container
				let section = document.createElement("section");
				section.className = "list-item";
				section.appendChild(checkbox);
				section.appendChild(label);
				if (item.elaboration) {  // if there's an elaboration
					let img = document.createElement("img");
					img.src = "expandable.svg";
					img.className = "icon";
					section.appendChild(img);
				}
				let elements = document.createElement("div");
				elements.appendChild(section);
				
				// crosses out finished items
				if (done) {
					if (then.getTime() < now.getTime() && recurrence != "indefinite" && recurrence != "continual") {
						pastDueNumber--;
					}
					label.style.textDecoration = "line-through";
					label.title = "Finished";
					label.style.color = "inherit";
					label.style.fontWeight = "inherit";
					if (label.children.length > 0) {  // if there's a <mark> tag
						label.children[0].style.background = "inherit";
					}
					if (recurrence != "indefinite" && recurrence != "once" && now.getTime() > then.getTime()) {
						lastFinished = then.getTime() + 1;
						done = false;
						let storedItem = M[storagePlace].recall(description);
						storedItem.lastFinished = lastFinished;
						storedItem.done = done;
						M[storagePlace].store(description, storedItem);
						var needsToRunFunctionAgain = true;
					}
				}
				/*
				if (done) {
					function handler(mutations, observer) {
						mutations.forEach(function(mutation) {
							mutation.addedNodes.forEach(function(node) {
								if (node == checkbox) {
									checkbox.check();
									watcher.disconnect();
								}
							});
						});
					}
					var watcher = new MutationObserver(handler) || webkitMutationObserver(handler);
					watcher.observe(getId("list"), {"childList":true, "subtree":true});
				}
				*/
				
				// adds the item to the priority list or runs the function again
				if (needsToRunFunctionAgain) {
					item.time = originalDate;
					item.lastFinished = lastFinished;
					item.done = done;
					makeDynamicItem(description, item);
				} else {
					if (isNaN(urgency) || S.getType(urgency) != "Number") {
						throw 'The item with the description "' + decodeURIComponent(description) + '" has a non-number urgency.';
					}
					let increment = 0;
					while (itemSet[urgency + increment] != undefined) {
						// while there's a target key value already taken, increase the target key by 1
						// (prevents overwriting when things have the same due-date and importance)
						increment++;
					}
					itemSet[urgency+increment] = {description: decodeURIComponent(description), importance: importance, done: done, elements: elements.innerHTML, labels: labels};
				}
			}


			function makeStaticItem(description, item) {
				/**
				adds a static list item to itemSet
				*/

				// creates the HTML objects to be displayed
				let checkbox = document.createElement("input");
				checkbox.type = "checkbox";
				checkbox.id = "item" + itemNumber++;
				let label = document.createElement("span");
				label.title = "Item position: " + item.position;
				label.innerHTML = decodeURIComponent(description);

				// sets label highlighting
				if (!item.positioned && !item.done) {
					label.innerHTML = "<mark>" + label.innerHTML + "</mark>";
				}

				// puts the elements into a container
				let section = document.createElement("section");
				section.className = "list-item";
				section.appendChild(checkbox);
				section.appendChild(label);
				if (item.elaboration) {  // if there's an elaboration
					let img = document.createElement("img");
					img.src = "expandable.svg";
					img.className = "icon";
					section.appendChild(img);
				}
				let elements = document.createElement("div");
				elements.appendChild(section);

				// crosses out finished items
				if (item.done) {
					label.style.textDecoration = "line-through";
					label.title = "Finished";
				}

				if (item.position>0 && itemSet.hasOwnProperty(item.position-1) || item.position<0 && itemSet.hasOwnProperty(item.position)) {  // if the position is taken
					// corrects the stored items
					S.forEach(M[storagePlace].list(), function (key) {
						if (description != key) {
							let currentItem = M[storagePlace].recall(key);
							if (item.position > 0) {
								if (currentItem.position >= item.position) {
									currentItem.position++;
								}
							} else {
								if (currentItem.position <= item.position) {
									currentItem.position--;
								}
							}
							M[storagePlace].store(key, currentItem);
						}
					});
					// corrects the items in itemSet
					let newSet = [];
					S.forEach(itemSet, function (value, placement) {
						newSet.push({ placement: Number(placement), value: value });
					});
					S.forEach(newSet, function (currentItem) {
						if (item.position > 0) {
							if (currentItem.placement >= item.position - 1) {
								currentItem.placement++;
							}
						} else {
							if (currentItem.placement <= item.position - 1) {
								currentItem.placement--;
							}
						}
					});
					itemSet = {};
					S.forEach(newSet, function (obj) {
						itemSet[obj.placement] = obj.value;
					});
				}

				if (item.position > 0) {
					itemSet[item.position-1] = { description: decodeURIComponent(description), importance: item.importance, done: item.done, elements: elements.innerHTML, labels: item.labels };
				} else {
					itemSet[item.position] = { description: decodeURIComponent(description), importance: item.importance, done: item.done, elements: elements.innerHTML, labels: item.labels };
				}
			}


			function makeRandomItem(description, item) {
				/**
				adds a randomly ordered list item to itemSet
				*/

				// creates the HTML objects to be displayed
				let checkbox = document.createElement("input");
				checkbox.type = "checkbox";
				checkbox.id = "item" + itemNumber++;
				let label = document.createElement("span");
				label.title = "Importance: " + item.importance;
				label.innerHTML = decodeURIComponent(description);

				// sets label highlighting
				if (now.getTime() - item.lastUpdated > 2000000000) {  // if it's been more than about 23 days
					label.style.fontWeight = "bold";
					if (importance == 5) {
						label.style.textDecoration = "underline";
					} else if (importance == 4) {
						label.style.WebkitTextDecorationStyle = "dotted";  // for Safari
						label.style.textDecoration = "underline dotted";
					}
					label.innerHTML = "<mark>" + label.innerHTML + "</mark>";
				} else if (now.getTime() - item.lastUpdated > 1000000000) {  // if it's been more than about 11.5 days
					label.innerHTML = "<mark style='background:#ffff88'>" + label.innerHTML + "</mark>";
				}

				// puts the elements into a container
				let section = document.createElement("section");
				section.className = "list-item";
				section.appendChild(checkbox);
				section.appendChild(label);
				if (item.elaboration) {  // if there's an elaboration
					let img = document.createElement("img");
					img.src = "expandable.svg";
					img.className = "icon";
					section.appendChild(img);
				}
				let elements = document.createElement("div");
				elements.appendChild(section);

				// crosses out finished items
				if (item.done) {
					label.style.textDecoration = "line-through";
					label.title = "Finished";
					label.style.color = "inherit";
					label.style.fontWeight = "inherit";
					if (label.children.length > 0) {  // if there's a <mark> tag
						label.children[0].style.background = "inherit";
					}
				}

				// sets the placement
				let placement = Math.round((6-item.importance) * 100 + Math.random() * 100 - 50);

				// adds the item to the priority list
				let increment = 0;
				while (itemSet[placement + increment] != undefined) {
					// while there's a target key value already taken, increase the target key by 1
					// (prevents overwriting when things have the same due-date and importance)
					increment++;
				}
				itemSet[placement + increment] = { description: decodeURIComponent(description), importance: item.importance, done: item.done, elements: elements.innerHTML, labels: item.labels };
			}




			function includeDynamicItem() {
				let enoughInformation = true;
				if (!(S.getId("description").value.trim() && S.getId("importance").value && S.getId("recurrence").value)) {
					enoughInformation = false;
				} else {
					if (S.getId("recurrence").value == "indefinite") {
						if (!S.getId("timeframe").value) {
							enoughInformation = false;
						}
					} else if (S.getId("recurrence").value != "continual") {
						if (!S.getId("time").value) {
							enoughInformation = false;
						}
					}
				}
				if (enoughInformation) {
					now = new Date();
					let description = encode(S.getId("description").value.trim());
					let date = "";
					let time = S.getId("time").value.trim();
					if (time.search(/\d(?:am|pm)/) > -1) {  // if there's an am or pm not preceeded by a space
						time = time.slice(0, time.indexOf("m")-1) + " " + time.slice(time.indexOf("m")-1);
					}
					switch (S.getId("recurrence").value) {
						case "continual":
							date = now.getTime() + Math.pow(6-Number(S.getId("importance").value), 2) * 200000000;
						case "indefinite":
							switch (S.getId("timeframe").value) {  // sets when the highlight will become most apparent
								case "immediately":
									date = 0;  // now
									break;
								case "soon":
									date = 250000000;  // in a little less than 3 days
									break;
								case "later":
									date = 700000000;  // in a little more than 8 days
									break;
								case "aWhile":
									date = 1600000000;  // in about 18.5 days
									break;
								case "somePoint":
									date = 3628800000;  // in exactly 42 days
									break;
								case "same":
									date = Number(M[storagePlace].recall(description).time.split("~")[0]) - now.getTime();  // at the pre-estblished time
									break;
							}
							if (time > 0 && S.getId("timeframe").value != "same") {
								date += date*.1 * (Math.random()*2-1);  // varies the time set by 10% (helps prevent a bunch of things being due at the same time)
							}
							date += now.getTime();
							break;
						case "once":
							date = S.getId("fullDate").value.replace(/-/g, " ");
							/* //// previously for quick selecting with a day of the week
							var then = S.getId("fullDate").value;
							then = week.indexOf(then.toLowerCase());
							if (now.getDay() == then) {
								if (now.getTime() <= new Date([now.getFullYear(), now.getMonth() + 1, now.getDate()].join(" ") + " " + time).getTime()) {
									date = now.getMonth() + 1 + "/" + now.getDate() + "/" + now.getFullYear();
								} else {
									then = new Date(now.getTime() + 604800000);
									date = then.getMonth() + 1 + "/" + then.getDate() + "/" + then.getFullYear();
								}
							} else if (now.getDay() < then) {
								then = new Date(now.getTime() + (then - now.getDay()) * 86400000);
								date = then.getMonth() + 1 + "/" + then.getDate() + "/" + then.getFullYear();
							} else {
								then = new Date(now.getTime() + (7 + then - now.getDay()) * 86400000);
								date = then.getMonth() + 1 + "/" + then.getDate() + "/" + then.getFullYear();
							}
							*/
							break;
						case "monthly":
							date = S.getId("day").value;
							break;
						case "weekly":
							let numberChecked = 0;
							week.forEach(function(ID) {
								if (S.getId(ID).checked) {
									date += ID + " ";
									numberChecked++;
								}
							});
							if (numberChecked == 0) {  //// This checking should integrate with enoughInformation.
								S.makeDialog("You need to check at least one day of the week.");
								return;
							}
							date.trim();
							break;
					}
					date += "~" + time;
					// sets labels
					let labels = S.getId("labels").value.trim().split(",");
					S.forEach(labels, function (label, index) {
						labels[index] = label.trim();
					});
					// stores the information
					if (S.getId("recurrence").value == "indefinite" && S.getId("timeframe").value == "same") {
						M[storagePlace].store(description, { importance: S.getId("importance").value, time: date, recurrence: S.getId("recurrence").value, lastFinished: M[storagePlace].recall(description).lastFinished, lastUpdated: now.getTime(), done: false, labels: labels, elaboration: S.getId(advancedEditorSection, "elaboration").value, difficulty: Number(advancedEditorSection.querySelector("#difficulty").value) });
					} else {
						M[storagePlace].store(description, { importance: S.getId("importance").value, time: date, recurrence: S.getId("recurrence").value, lastFinished: now.getTime(), lastUpdated: now.getTime(), done: false, labels: labels, elaboration: S.getId(advancedEditorSection, "elaboration").value, difficulty: Number(advancedEditorSection.querySelector("#difficulty").value) });
					}
					// resets stuff
					cancel();
					// refreshes the list
					refresh();
					setTimeout(function () {
						refresh(true);
					}, 0);
					// randomly displays inspiring messages (if desired)
					if (S.getId(advancedSettingsSection, "inspiringMessages").checked && Math.floor(Math.random()*5) == 0) {
						let messages = ["You're the best!", "You're worth it.", "Nothing can stop you.", "You rock!", "You're an amazing person.", "The world wouldn't be the same without you.", "I love you."];
						S.makeDialog(messages[Math.floor(Math.random()*messages.length)], "Thank you");
					}
				} else {
					S.makeDialog("You left out at least one required field.");
				}
			}

			function includeStaticItem() {
				let enoughInformation = true;
				if (S.getId("description").value.trim() == "") {
					enoughInformation = false;
				}
				if (enoughInformation) {
					now = new Date();
					// sets the position
					let position;
					let unfinishedListLength = 0;
					let positioned = false;
					S.forEach(M[storagePlace].list(), function (key) {
						if (!M[storagePlace].recall(key).done) {
							unfinishedListLength++;
						}
					});
					if (S.getId("positioner").value.trim() == "") {
						if (S.getId("importance").value == "") {
							position = unfinishedListLength + 1;
						} else {
							position = Math.ceil(unfinishedListLength * (6-Number(S.getId("importance").value)) / 5 + 1);
							positioned = true;
						}
					} else {
						position = Number(S.getId("positioner").value);
						positioned = true;
					}
					if (position < 1) {
						position = 1;
					}
					if (position > unfinishedListLength + 1) {
						position = unfinishedListLength + 1;
					} else if (position < unfinishedListLength + 1) {
						S.forEach(M[storagePlace].list(), function (key) {
							let item = M[storagePlace].recall(key);
							if (item.position >= position) {
								item.position++;
								M[storagePlace].store(key, item);
							}
						});
					}
					// sets labels
					let labels = S.getId("labels").value.trim().split(",");
					S.forEach(labels, function (label, index) {
						labels[index] = label.trim();
					});
					// stores the information
					M[storagePlace].store(encode(S.getId("description").value.trim()), { position: position, importance: S.getId("importance").value, done: false, positioned: positioned, lastFinished: now.getTime(), lastUpdated: now.getTime(), labels: labels, elaboration: S.getId(advancedEditorSection, "elaboration").value });
					// resets stuff
					cancel();
					// refreshes the list
					refresh();
					setTimeout(function () {
						refresh(true);
					}, 0);
					// randomly displays inspiring messages (if desired)
					if (S.getId(advancedSettingsSection, "inspiringMessages").checked && Math.floor(Math.random()*5) == 0) {
						let messages = ["You're the best!", "You're worth it.", "Nothing can stop you.", "You rock!", "You're an amazing person.", "The world wouldn't be the same without you.", "I love you."];
						S.makeDialog(messages[Math.floor(Math.random()*messages.length)], "Thank you");
					}
				} else {
					S.makeDialog("You left out at least one required field.");
				}
			}

			function includeRandomItem() {
				let enoughInformation = true;
				if (S.getId("description").value.trim() == "" || S.getId("importance").value == "") {
					enoughInformation = false;
				}
				if (enoughInformation) {
					now = new Date();
					// sets labels
					let labels = S.getId("labels").value.trim().split(",");
					S.forEach(labels, function (label, index) {
						labels[index] = label.trim();
					});
					// stores the information
					M[storagePlace].store(encode(S.getId("description").value.trim()), { importance: S.getId("importance").value, done: false, lastUpdated: now.getTime(), labels: labels, elaboration: S.getId(advancedEditorSection, "elaboration").value });
					// resets stuff
					cancel();
					// refreshes the list
					refresh();
					setTimeout(function () {
						refresh(true);
					}, 0);
					// randomly displays inspiring messages (if desired)
					if (S.getId(advancedSettingsSection, "inspiringMessages").checked && Math.floor(Math.random() * 5) == 0) {
						let messages = ["You're the best!", "You're worth it.", "Nothing can stop you.", "You rock!", "You're an amazing person.", "The world wouldn't be the same without you."];  //, "I love you."];
						S.makeDialog(messages[Math.floor(Math.random() * messages.length)], "Thank you");
					}
				} else {
					S.makeDialog("You left out at least one required field.");
				}
			}




			function showHide() {
				switch (S.getId("recurrence").value) {
					case "indefinite":
						S.getId("once").style.display = "none";
						S.getId("weekly").style.display = "none";
						S.getId("monthly").style.display = "none";
						S.getId("timeSection").style.display = "none";
						S.getId("indefinite").style.display = "block";
						break;
					case "once":
						S.getId("indefinite").style.display = "none";
						S.getId("monthly").style.display = "none";
						S.getId("weekly").style.display = "none";
						S.getId("once").style.display = "block";
						S.getId("timeSection").style.display = "block";
						break;
					case "monthly":
						S.getId("indefinite").style.display = "none";
						S.getId("once").style.display = "none";
						S.getId("weekly").style.display = "none";
						S.getId("monthly").style.display = "block";
						S.getId("timeSection").style.display = "block";
						break;
					case "weekly":
						S.getId("indefinite").style.display = "none";
						S.getId("once").style.display = "none";
						S.getId("monthly").style.display = "none";
						S.getId("weekly").style.display = "table";
						S.getId("timeSection").style.display = "block";
						break;
					case "daily":
						S.getId("indefinite").style.display = "none";
						S.getId("once").style.display = "none";
						S.getId("monthly").style.display = "none";
						S.getId("weekly").style.display = "none";
						S.getId("timeSection").style.display = "block";
						break;
					case "continual":
					default:
						S.getId("indefinite").style.display = "none";
						S.getId("once").style.display = "none";
						S.getId("monthly").style.display = "none";
						S.getId("weekly").style.display = "none";
						S.getId("timeSection").style.display = "none";
						break;
				}
			}




			function mergeInformation() {
				////
				now = new Date();
				S.getId("list").innerHTML = "<p>Syncing your data...</p>";
				itemSet = {};
				pastDueNumber = 0;
				dueTodayNumber = 0;
				recyclingBin = {};
				////
				//*
				M.server.defaultLocation = "/lists/";

				let mergingPromises = [];
				// merges all of the individual items (prevents needing to consider all items together as one group for each list)
				mergingPromises.push(M.server.mergeData(
					info => {
						console.log("preferClient:");
						console.log(info);
						return info.clientData.lastUpdated > info.serverData.lastUpdated;
					},
					function (info, syncTimes) {
						console.log("keepMissing:");
						console.log(info);
						console.log(syncTimes);
						if (info.serverData === undefined || info.serverData instanceof Error) {  // if the data is from the client
							return info.clientData.lastUpdated > syncTimes[0];
						} else {  // if the data is from the server
							return syncTimes[0] < syncTimes[1];
						}
					},
					"*/items/*",
					"*/items/*",
					{
						storageType: storagePlace,
						prepTasks: [M[storagePlace].recall("/lists/last synchronized"), M.server.recall("/lists/last synchronized")]
					}
				).catch(function (error) {
					console.error("There was a problem merging the list items.");
					console.error(error);
				}));
				// merges the list settings and lastUpdated
				mergingPromises.push(M.server.mergeData(
					function (info) {
						console.log("preferClient:");
						console.log(info);
						if (info.location.slice(-11) == "lastUpdated") {
							return info.clientData > info.serverData;
						} else {  // if it's list settings
							return info.clientData.lastUpdated > info.serverData.lastUpdated;
						}
					},
					function (info, syncTimes) {
						console.log("keepMissing:");
						console.log(info);
						console.log(syncTimes);
						if (info.serverData === undefined || info.serverData instanceof Error) {  // if the data is from the client
							if (info.location.slice(-11) == "lastUpdated") {
								return info.clientData > syncTimes[0];
							} else {  // if it's list settings
								return info.clientData.lastUpdated > syncTimes[0];
							}
						} else {  // if the data is from the server
							return syncTimes[0] < syncTimes[1];
						}
					},
					"",
					"",
					{
						maxDepth: 2,
						storageType: storagePlace,
						ignoreInServer: ["last synchronized", "*/items/"],
						ignoreInClient: ["last synchronized", "*/items/", "start-up settings"],
						prepTasks: [M[storagePlace].recall("/lists/last synchronized"), M.server.recall("/lists/last synchronized")]
					}
				).catch(function (error) {
					console.error("There was a problem merging the list settings and lastUpdated.");
					console.error(error);
				}));

				S.getId("settingsSection").children[1].style.display = "none";

				Promise.all(mergingPromises).then(function () {
					window.dispatchEvent(new Event("readyToRefresh"));
					// updates the last synchronized times
					M[storagePlace].store("/lists/last synchronized", now.getTime());
					M.server.store("/lists/last synchronized", now.getTime()).catch(function (error) {
						console.error('The "last synchronized" time couldn\'t be updated on the server.');
						console.error(error);
					});
				}).catch(function (error) {
					console.error("There was a problem merging the information.");
					console.error(error);
					S.makeDialog("An error occurred while attempting to sync your information.");
				});
				/*/
				////
				new Promise(function (resolve, reject) {
					if (localTakesPrecedence) {  // if the local information should be given precedence over the server information
						S.getId("list").innerHTML = "<p>Storing your data...</p>";
						let information = M[storagePlace].list("/lists/");
						information.splice(information.indexOf("start-up settings"), 1);
						let listenable = new S.Listenable();
						listenable.value = 0;
						listenable.addEventListener("set", function (value) {
							if (value >= information.length) {  // when all items have been stored
								S.getId("list").innerHTML = "<p>Deleting unwanted server information...</p>";
								listenable.removeEventListener("set", arguments.callee);
								listenable.value = undefined;
								M.server.list("./").then(function (data) {
									listenable.value = 0;
									listenable.addEventListener("set", function (itemsLeft) {
										if (itemsLeft == 0) {
											listenable.removeEventListener("set", arguments.callee);
											resolve();
										}
									});
									if (data.length > 0) {
										// deletes account data not not present in the current data
										let deleting = false;
										S.forEach(data, function (key) {
											if (!information.includes(key)) {
												deleting = true;
												listenable.value++;
												recyclingBin[key] = {  // basically just retains the description as a reminder in case worst comes to worst
													importance: 5,
													recurrence: "indefinite",
													time: now.getTime() + "~",
													difficulty: 3,
													lastFinished: now.getTime(),
													done: false,
													lastUpdated: now.getTime()
												};
												M.server.forget("./" + key, function () {
													listenable.value--;
												}).catch(function (error) {
													reject(error);
												});
											}
										});
										if (!deleting) {
											listenable.value = 0;
										}
									} else {
										resolve();
									}
								}).catch(function (error) {
									reject(error);
								});
							}
						});
						if (information.length > 0) {
							// stores and replaces account data with current data
							S.forEach(information, function (key) {
								M.server.store("./" + key, M[storagePlace].recall("/lists/" + key)).then(function () {
									listenable.value++;
								}).catch(function (error) {
									reject(error);
								});
							});
						} else {
							listenable.value++;
						}
					} else {  // if the server information should be given precedence over the local information
						S.getId("list").innerHTML = "<p>Retrieving stored information...</p>";
						M.server.list("./").then(function (list) {
							S.getId("list").innerHTML = "<p>Deleting unwanted local information...</p>";
							let listenable = new S.Listenable();
							listenable.addEventListener("set", function (index) {
								M.server.recall("./" + list[index], function (data) {
									M[storagePlace].store("/lists/" + list[index], data);
									if (index + 1 >= list.length) {  // once all items have been iterated through
										S.forEach(M[storagePlace].list("/lists/"), function (key) {
											if (!list.includes(key) && key != "start-up settings" && key != "last synchronized") {
												recyclingBin[key] = M[storagePlace].recall("/lists/" + key);  // holds on to deleted items just in case
												M[storagePlace].forget("/lists/" + key);
											}
										});
										resolve();
									}
								}).catch(function (error) {
									reject(error);
								});
								if (index + 1 < list.length) {
									listenable.value++;
								} else {
									listenable.removeEventListener("set", arguments.callee);
								}
							});
							listenable.value = 0;
						}).catch(function (error) {
							reject(error);
						});
					}
				}).catch(function (error) {
					console.error("There was a problem merging the information.");
					console.error(error);
					S.makeDialog("An error occurred while attempting to sync your information.");
				}).then(function () {
					window.dispatchEvent(new Event("readyToRefresh"));
				});
				S.getId("settingsSection").children[1].style.display = "none";
				//*/
			}




			function refresh(shouldSync) {

				now = new Date();
				S.getId("list").innerHTML = "<p>Syncing your data...</p>";
				itemSet = {};
				pastDueNumber = 0;
				dueTodayNumber = 0;
				labelList = [];
				// syncs data if desired and possible
				if (shouldSync && S.getId("syncData").checked && M.server.user) {
					/*
					if (mergeData) {  // if the existing data should be merged to the account data
						mergeInformation(true);
					} else {
						useLocal = false;
						// stores and replaces current session data with account data
						M.server.list(undefined, function (list) {
							listenable.addEventListener("change", function (index) {
								M.server.recall(list[index].id, undefined, function (data) {
									M.session.store(list[index].id, data);
									if (index + 1 >= list.length) {
										window.dispatchEvent(new Event("readyToRefresh"));
									}
								});
								if (index + 1 < list.length) {
									listenable.value++;
								} else {
									listenable.removeEventListener("change", arguments.callee);
								}
							});
							listenable.value = 0;
						});
					}
					*/
				} else {
					window.dispatchEvent(new Event("readyToRefresh"));
				}
			}
			window.addEventListener("readyToRefresh", function () {

				S.getClass("main-title")[0].textContent = decodeURIComponent(M[storagePlace].defaultLocation.split("/")[1]);  // sets the title

				S.getId("list").innerHTML = "";
				S.getId("labelContainer").innerHTML = "";
				S.getId("listList").innerHTML = "";
				S.getId("defaultList").innerHTML = "";
				// fills itemSet
				if (M[storagePlace].recall("../settings/ordering") instanceof Error) {  //// for some reason, this can be true
					M[storagePlace].store("../settings/ordering", "dynamic");
				}
				switch (M[storagePlace].recall("../settings/ordering")) {
					case "dynamic":
						S.getId("staticEditor").style.display = "none";
						S.getId("dynamicEditor").style.display = "block";
						S.getId("randomEditor").style.display = "none";
						M[storagePlace].list().forEach(function (key) {
							makeDynamicItem(key, M[storagePlace].recall(key));
						});
						break;
					case "static":
						S.getId("dynamicEditor").style.display = "none";
						S.getId("staticEditor").style.display = "block";
						S.getId("randomEditor").style.display = "none";
						M[storagePlace].list().forEach(function (key) {
							makeStaticItem(key, M[storagePlace].recall(key));
						});
						// ensures that item positions don't leave gaps
						S.forEach(itemSet, function (item, placement, instances, index) {
							if (Number(placement) >= 0) {  // avoids crossed-out items
								let storedItem = M[storagePlace].recall(encode(item.description));
								storedItem.position = index + 1;
								M[storagePlace].store(encode(item.description), storedItem);
							}
						});
						itemSet = {};
						M[storagePlace].list().forEach(function (key) {
							makeStaticItem(key, M[storagePlace].recall(key));
						});
						break;
					case "random":
						S.getId("dynamicEditor").style.display = "none";
						S.getId("staticEditor").style.display = "none";
						S.getId("randomEditor").style.display = "block";
						M[storagePlace].list().forEach(function (key) {
							makeRandomItem(key, M[storagePlace].recall(key));
						});
						break;
					default:
						throw "An invalid ordering type was selected.";
				}
				// adds list settings if necessary
				if (M[storagePlace].recall("../settings/ordering") instanceof Error) {
					M[storagePlace].store("../settings/ordering", "dynamic");
				}
				advancedSettingsSection.querySelector("#listOrdering").value = M[storagePlace].recall("../settings/ordering");
				if (M[storagePlace].recall("../settings/filter") instanceof Error) {
					M[storagePlace].store("../settings/filter", []);
				}
				// declares necessary variables
				let list = [],
					currentIndex = 0,
					alreadyCounted = [];
				// puts items from the itemSet object into an array
				// allows filtering items
				if (S.getId("listFilter").value.trim() || S.toArray(S.getId("importanceFilter").getElementsByTagName("input")).some(function (box) {return box.checked;})) {
					let labelsToInclude = S.getId("listFilter").value.trim().split(",");
					S.forEach(labelsToInclude, function (label, index) {
						labelsToInclude[index] = label.trim();
					});
					if (labelsToInclude[0] === "") {  // prevents empty labels from being counted as matching
						labelsToInclude.shift();
					}
					let importanceLevels = S.toArray(S.getId("importanceFilter").getElementsByTagName("input"));
					S.forEach(itemSet, function (item) {
						let shouldAdd = true;
						// checks labels
						if (S.getId("listFilter").value.trim() && !(item.labels && item.labels.some(function (label) {
							return labelsToInclude.includes(label);
						}))) {
							shouldAdd = false;
						}
						// checks importance
						if (importanceLevels.some(function (box) {
							return box.checked;
						}) && !S.getId("importanceFilter").getElementsByTagName("input")[Number(item.importance) - 1].checked) {
							shouldAdd = false;
						}
						// adds valid items
						if (shouldAdd) {
							list.push(item);
						}
					});
				} else {
					S.forEach(itemSet, function (item) {
						list.push(item);
					});
				}
				// moves finished items to the end (already done with static items)
				if (M[storagePlace].recall("../settings/ordering") != "static") {
					while (currentIndex < list.length && alreadyCounted.indexOf(list[currentIndex].description) == -1) {
						if (list[currentIndex].done) {
							alreadyCounted.push(list[currentIndex].description);
							list.move(currentIndex);
						} else {
							currentIndex++;
						}
					}
				}
				// inserts the items onto the page
				let HTML = "";
				list.forEach(function (instance) {
					HTML += instance.elements;
				});
				S.getId("list").innerHTML = HTML;
				// checks off finished checkboxes
				list.forEach(function (instance, index) {
					if (instance.done) {
						S.getId("list").getElementsByTagName("input")[index].checked = true;
					}
				});
				// shows how many items are present in the list
				if (list.length == 1) {
					S.getId("numberOfFilteredItems").textContent = list.length + " item satisfies this filter";
				} else {
					S.getId("numberOfFilteredItems").textContent = list.length + " items satisfy this filter";
				}
				// adds a notification of past-due items
				if (pastDueNumber > 0) {
					S.getId("pastDueNotifier").textContent = pastDueNumber;
					S.getId("pastDueNotifier").style.display = "inline-block";
				} else {
					S.getId("pastDueNotifier").style.display = "none";
				}
				S.getId("pastDueItems").textContent = pastDueNumber;
				// adds an indicator of what's due the same day
				S.getId("dueTodayItems").textContent = "_"  //// dueTodayNumber;
				// lists the lists
				let listArray = [];
				M[storagePlace].list("/lists/").forEach(function (location) {
					if (location != "start-up settings" && location != "last synchronized") {
						let listName = location.slice(0, location.indexOf("/"));
						if (!listArray.includes(listName)) {
							listArray.push(listName);
						}
					}
				});
				listArray.forEach(function (title) {
					let button = document.createElement("button");
					button.className = "subtle";
					button.textContent = decodeURIComponent(title);
					button.addEventListener("click", function () {
						S.getId("listsSection").children[1].style.display = "none";
						M[storagePlace].defaultLocation = "lists/" + title + "/items";
						currentList = title;
						recyclingBin = {};
						refresh();
					});
					S.getId("listList").appendChild(button);
				});
				listArray.forEach(function (title) {
					let option = document.createElement("option");
					option.value = title;
					option.textContent = decodeURIComponent(title);
					S.getId("defaultList").appendChild(option);
				});
				S.getId("defaultList").value = M[storagePlace].recall("/lists/start-up settings").list;
				// lists all labels
				list.forEach(function (item) {
					if (item.labels) {
						item.labels.forEach(function (label) {
							if (!labelList.includes(label)) {
								labelList.push(label);
							}
						});
					}
				});
				labelList.sort();
				if (labelList.length > 0 && labelList[0] === "") {
					labelList.shift();
				}
				labelList.forEach(function (label, index) {
					let element = document.createElement("div");
					element.innerHTML = '<input type="checkbox"><label>' + label + '</label>';
					S.getId("labelContainer").appendChild(element);
					if (index < labelList.length - 1) {
						S.getId("labelContainer").appendChild(document.createElement("br"));
					}
				});

				if (S.getId("list").innerHTML == "") {
					// adds a prompt if there's no items saved
					S.getId("list").innerHTML = "<p>Add some things to do.</p>";
				} else {
					// sets list item listeners
					list.forEach(function (listItem, index) {
						// listens for clicking on a checkbox
						// (toggles the item's "done" property)
						S.listen(S.getId("list").getElementsByTagName("input")[index], "click", function () {
							let item = M[storagePlace].recall(encode(listItem.description));
							if (item.recurrence == "continual") {
								item.lastFinished = now.getTime();
								item.time = now.getTime() + Math.pow(6-item.importance, 2) * 200000000 + "~";
							} else {
								if (this.checked) {
									item.done = true;
								} else {
									item.done = false;
								}
							}
							if (M[storagePlace].recall("../settings/ordering") == "static") {
								item.position = -item.position;
							}
							item.lastUpdated = now.getTime();
							M[storagePlace].store(encode(listItem.description), item);
							refresh();
						});
						// listens for double-clicking on a description
						// (pulls up the editor for that item)
						if (M[storagePlace].recall("../settings/ordering") == "dynamic") {
							function fillDynamicEditor() {
								// prevents highlighting the text when double-clicking
								// event.preventDefault() would only work with onmousedown
								if (document.selection && document.selection.empty) {
									document.selection.empty();
								} else if (window.getSelection) {
									window.getSelection().removeAllRanges();
								}
								let item = M[storagePlace].recall(encode(listItem.description));
								S.getId("description").value = listItem.description;
								S.getId("importance").value = item.importance;
								S.getId("recurrence").value = item.recurrence;
								switch (item.recurrence) {
									case "indefinite":
										/*
										let indefiniteTime = Number(item.time.split("~")[0]) - now.getTime();
										if (indefiniteTime <= 0) {
											indefiniteTime = "immediately";
										} else if (indefiniteTime <= 250000000) {
											indefiniteTime = "soon";
										} else if (indefiniteTime <= 700000000) {
											indefiniteTime = "later";
										} else if (indefiniteTime <= 1600000000) {
											indefiniteTime = "aWhile";
										} else {
											indefiniteTime = "somePoint";
										}
										*/
										S.getId("timeframe").options["same"].disabled = false;
										S.getId("timeframe").value = "same";
										break;
									case "once":
										if (item.time.includes("/")) {  ////
											let date = item.time.split("~")[0].split("/");
											date = date[2] + "-" + (date[0].length>1 ? "" : "0") + date[0] + "-" + (date[1].length>1 ? "" : "0") + date[1];
											S.getId("fullDate").value = date;
										} else {
											S.getId("fullDate").value = item.time.split("~")[0].replace(/ /g, "-");
										}
										break;
									case "monthly":
										S.getId("day").value = item.time.split("~")[0];
										break;
									case "weekly":
										week.forEach(function (ID) {
											S.getId(ID).checked = false;
										});
										item.time.split("~")[0].trim().split(" ").forEach(function (ID) {
											S.getId(ID).checked = true;
										});
										break;
								}
								if (item.recurrence != "indefinite" && item.recurrence != "continual") {
									S.getId("time").value = item.time.split("~")[1];
								}
								if (item.labels) {
									S.getId("labels").value = item.labels.join(", ");
								}
								if (item.elaboration) {
									S.getId(advancedEditorSection, "elaboration").value = item.elaboration;
								}
								advancedEditorSection.querySelector("#difficulty").value = item.difficulty || 3;
								itemBeingEdited = listItem.description;
								showHide();
								S.getId("editorSection").children[1].style.display = "block";
							}

							S.listen(S.getId("list").getElementsByTagName("span")[index], "dblclick", function () {  // allows easy list item editing (on the computer)
								fillDynamicEditor();
							});
							// listens for touching and holding on a description
							// (pulls up the editor for that item)
							S.listen(S.getId("list").getElementsByTagName("span")[index], "touchhold", function () {// allows easy list item editing (on touchscreen device)
								fillDynamicEditor();
							});

						} else if (M[storagePlace].recall("../settings/ordering") == "static") {
							function fillStaticEditor() {
								// prevents highlighting the text when double-clicking
								// event.preventDefault() would only work with onmousedown
								if (document.selection && document.selection.empty) {
									document.selection.empty();
								} else if (window.getSelection) {
									window.getSelection().removeAllRanges();
								}
								let item = M[storagePlace].recall(encode(listItem.description));
								S.getId("description").value = listItem.description;
								S.getId("positioner").value = item.position;
								if (item.labels) {
									S.getId("labels").value = item.labels.join(", ");
								}
								if (item.elaboration) {
									S.getId(advancedEditorSection, "elaboration").value = item.elaboration;
								}
								advancedEditorSection.querySelector("#difficulty").value = item.difficulty || 3;
								itemBeingEdited = listItem.description;
								S.getId("editorSection").children[1].style.display = "block";
							}

							S.listen(S.getId("list").getElementsByTagName("span")[index], "dblclick", function () {  // allows easy list item editing (on the computer)
								fillStaticEditor();
							});
							S.listen(S.getId("list").getElementsByTagName("span")[index], "touchhold", function () {// allows easy list item editing (on touchscreen device)
								fillStaticEditor();
							});

						} else if (M[storagePlace].recall("../settings/ordering") == "random") {
							function fillRandomEditor() {
								// prevents highlighting the text when double-clicking
								// event.preventDefault() would only work with onmousedown
								if (document.selection && document.selection.empty) {
									document.selection.empty();
								} else if (window.getSelection) {
									window.getSelection().removeAllRanges();
								}
								let item = M[storagePlace].recall(encode(listItem.description));
								S.getId("description").value = listItem.description;
								S.getId("importance").value = listItem.importance;
								if (item.labels) {
									S.getId("labels").value = item.labels.join(", ");
								}
								if (item.elaboration) {
									S.getId(advancedEditorSection, "elaboration").value = item.elaboration;
								}
								advancedEditorSection.querySelector("#difficulty").value = item.difficulty || 3;
								itemBeingEdited = listItem.description;
								S.getId("editorSection").children[1].style.display = "block";
							}

							S.listen(S.getId("list").getElementsByTagName("span")[index], "dblclick", function () {  // allows easy list item editing (on the computer)
								fillRandomEditor();
							});
							S.listen(S.getId("list").getElementsByTagName("span")[index], "touchhold", function () {// allows easy list item editing (on touchscreen device)
								fillRandomEditor();
							});
						}
					});
				}
				S.getId("recurrence").value = "";
				showHide();
				S.getId("editorSection").children[1].style.display = "none";
			});




			function remove() {
				let location = M[storagePlace];
				if (S.getId("description").value.trim() == "") {
					location.list().forEach(function (key) {
						let item = location.recall(key);
						if (item.done && (item.recurrence == "indefinite" || item.recurrence == "once" || location.recall("../settings/ordering") == "static" || location.recall("../settings/ordering") == "random")) {
							recyclingBin[key] = location.recall(key);
							location.forget(key);
						}
					});
				} else {
					let key = encode(S.getId("description").value.trim());
					recyclingBin[key] = location.recall(key);
					location.forget(key);
				}
				cancel();
				refresh();
			}

			function cancel() {
				S.forEach(S.getId("editorSection").children[1].getElementsByTagName("input"), function (input) {
					if (input.type == "checkbox") {
						input.checked = false;
					} else {
						input.value = "";
					}
				});
				S.forEach(S.getId("editorSection").children[1].getElementsByTagName("select"), function (select) {
					select.value = "";
				});
				S.forEach(["elaboration"], function (ID) {
					advancedEditorSection.querySelector("#" + ID).value = "";
				});
				advancedEditorSection.querySelector("#difficulty").value = 3;
				itemBeingEdited = "";
				showHide();
				S.getId("editorSection").children[1].style.display = "none";
			}

			S.listen("listFilter", "change", function () {
				if (this.value.trim() || S.toArray(S.getId("importanceFilter").getElementsByTagName("input")).some(function (box) { return box.checked; })) {
					S.getId("filterSection").children[0].style.color = "#0a0";
				} else {
					S.getId("filterSection").children[0].style.color = "";
				}
				refresh();
			});





			window.addEventListener("finished", function () {

				advancedSettingsSection = S.getId("advancedSettings");
				advancedSettingsSection.parentNode.removeChild(advancedSettingsSection);
				advancedEditorSection = S.getId("advancedEditor");
				S.removeSelf(advancedEditorSection);

				// sets or retrieves the start-up settings
				if (S.getType(M.local.recall("/lists/start-up settings")) != "Object") {
					let settings = {};
					settings.list = "Default";  // the list to start with
					settings.hide = [];  // what sections should be hidden
					settings.sync = false;  // whether the information should sync when logged in
					settings.volume = 100;  // the sound volume
					settings.inspiration = false;  // whether inspirational messages should be said
					settings.storageType = "local";  // whether information uses local or session storage (mainly for testing)
					M.local.store("/lists/start-up settings", settings);
				}
				if (S.getType(M.session.recall("/lists/start-up settings")) != "Object") {
					let settings = {};
					settings.list = "Default";  // the list to start with
					settings.hide = [];  // what sections should be hidden
					settings.sync = false;  // whether the information should sync when logged in
					settings.volume = 100;  // the sound volume
					settings.inspiration = false;  // whether inspirational messages should be said
					settings.storageType = "local";  // whether information uses local or session storage (mainly for testing)
					M.session.store("/lists/start-up settings", settings);
				}
				var siteSettings = M[storagePlace].recall("/lists/start-up settings");
				// sets the current list
				if (window.location.href.includes("?list=")) {
					currentList = window.location.href.slice(window.location.href.indexOf("=") + 1);
				} else {
					currentList = siteSettings.list;
				}
				M[storagePlace].defaultLocation = "lists/" + currentList + "/items";
				// sets the volume
				S.getId("soundVolume").value = siteSettings.volume;
				// sets the inspiration
				if (siteSettings.inspiration == true) {
					S.getId(advancedSettingsSection, "inspiringMessages").checked = true;
				}
				// sets the storage type
				if (siteSettings.storageType == "session") {
					S.getName("storagePlace")[0].checked = false;
					S.getName("storagePlace")[1].checked = true;
				}
				// sets which sections are visible
				if (siteSettings.hide.includes("filter")) {
					S.getId("filterSection").style.display = "none";
					S.getId("filterCheckbox").checked = false;
				}
				if (siteSettings.hide.includes("notifications")) {
					S.getId("notificationsSection").style.display = "none";
					S.getId("notificationsCheckbox").checked = false;
				}
				if (siteSettings.hide.includes("lists")) {
					S.getId("listsSection").style.display = "none";
					S.getId("listsCheckbox").checked = false;
				}

				// adds list settings if necessary
				if (M[storagePlace].recall("../settings/ordering") instanceof Error) {
					M[storagePlace].store("../settings/ordering", "dynamic");
				}
				if (M[storagePlace].recall("../settings/filter") instanceof Error) {
					M[storagePlace].store("../settings/filter", []);
				}
				if (M[storagePlace].recall("../settings/lastUpdated") instanceof Error) {
					M[storagePlace].store("../settings/lastUpdated", 0);
				}

				// adds listeners to the filter inputs
				S.forEach(S.getId("importanceFilter").getElementsByTagName("input"), function (box) {
					box.addEventListener("click", function () {
						if (S.getId("listFilter").value.trim() || S.toArray(this.parentNode.getElementsByTagName("input")).some(function (box) { return box.checked; })) {
							S.getId("filterSection").children[0].style.color = "#0a0";
						} else {
							S.getId("filterSection").children[0].style.color = "";
						}
						refresh();
					});
				});

				function startDoingStuff() {
					S.forEach(S.getTag("nav")[0].children, function (section) {  // allows basic mobile devices to access the drop-down menus
						section.children[0].addEventListener("click", function () {
							if (window.getComputedStyle(section.children[1]).display == "none") {
								section.children[1].style.display = "block";
							} else {
								section.children[1].style.display = "none";
							}
						});
					});

					refresh();
					S.getId("recurrence").addEventListener("change", showHide);
					setInterval(function () {  // refreshes a little under every 17 minutes
						refresh(true);
						let now = new Date();
						let time = now.getHours();
						if (new Date(now.getTime() - dayThreshold * 3600000).getDay() < 5) {  // if it's a week-night
							time += 1;
							if (time == 24) {
								time = 0;
							}
						}
						/*
						// tries to convince me to go to bed
						if (time == 21 && Math.floor(Math.random() * 2) == 0) {
							noisemaker.change("waveform", "sawtooth");
							noisemaker.play("a5--");
						} else if (time == 22) {
							noisemaker.change("waveform", "sawtooth");
							noisemaker.play("a5--");
						} else if (time == 23) {
							noisemaker.change("waveform", "sawtooth");
							noisemaker.play("a5-a5-");
							setTimeout(function () {
								noisemaker.change("waveform", "sawtooth");
								noisemaker.play("a5-a5-");
							}, 500000);
						} else if (time == 0) {
							noisemaker.change("waveform", "sawtooth");
							noisemaker.play("a4ssa5a4ssa5");
							setTimeout(function () {
								noisemaker.change("waveform", "sawtooth");
								noisemaker.play("a4ssa5a4ssa5");
							}, 250000);
							setTimeout(function () {
								noisemaker.change("waveform", "sawtooth");
								noisemaker.play("a4ssa5a4ssa5");
							}, 500000);
							setTimeout(function () {
								noisemaker.change("waveform", "sawtooth");
								noisemaker.play("a4ssa5a4ssa5");
							}, 750000);
						} else if (time == 1) {
							S.forEach(8, function (_, index) {
								setTimeout(function () {
									noisemaker.change("waveform", "sawtooth");
									noisemaker.play("a5a4a5a4");
								}, 125000 * index);
							});
						} else if (time >= 2 && time < dayThreshold && !noisemaker.playing) {
							noisemaker = new S.Sound({ frequency: 660, waveform: "square", changeWave: "sawtooth", modulation: 1, hertzChange: 220 });
							noisemaker.start();
						} else {
							noisemaker.change("waveform", "sine");
							if (now.getMonth() == 11 && Math.ceil(Math.random() * 3) == 3) {  // occasionally plays a part of "We Wish You a Merry Christmas" during December
								noisemaker.play("  a4---d5- d5-e5-d5-Db5-b4- b4- b4---e5- e5-F#5-e5-d5-C#5- a4- a4---F#5- F#5-g5-F#5-e5-d5- b4- a4-a4-b4-- e5- Db5- d5---", { noteLength: 75, attack: 30, decay: 30 });
							}
						}
						*/
						/*
						noisemaker.change("waveform", "sine");
						if (now.getMonth() == 11 && Math.ceil(Math.random() * 3) == 3) {  // occasionally plays a part of "We Wish You a Merry Christmas" during December
							noisemaker.play("  a4---d5- d5-e5-d5-Db5-b4- b4- b4---e5- e5-F#5-e5-d5-C#5- a4- a4---F#5- F#5-g5-F#5-e5-d5- b4- a4-a4-b4-- e5- Db5- d5---", { noteLength: 75, attack: 30, decay: 30 });
						}
						*/
						/*
						if (pastDueNumber > 0 && !(time >= 2 && time < dayThreshold)) {
							// makes an audible message for things that are past due
							setTimeout(function () {
								noisemaker.change("waveform", "square");
								noisemaker.play("a5sa4sa5 " + "a5 ".repeat(pastDueNumber));
							}, 15000);
						}
						*/
					}, 1000000);  // refreshes a little under every 17 minutes

					if (typeof firebase !== "undefined") {
						firebase.auth().onAuthStateChanged(function (user) {
							if (user) {
								S.getId("settingsSection").getElementsByTagName("button")[0].disabled = false;
								S.getId("settingsSection").getElementsByTagName("button")[1].disabled = false;
								if (S.getId("syncData").checked) {
									mergeData = confirm("Merge this data with your account data?");
									if (mergeData) {  ////
										if (M.session.list().length > 0) {
											S.forEach(M.session.list(), function (key) {
												M.local.store(key, M.session.recall(key));
											});
										}
										deleteData = confirm("Delete account data not present here?");
									}
								}
							} else {
								S.getId("settingsSection").getElementsByTagName("button")[0].disabled = true;
								S.getId("settingsSection").getElementsByTagName("button")[1].disabled = true;
							}
							refresh(true);
						});
					}
				}
				/*
				S.makeToneGenerator(true, function () {
					noisemaker = new S.Sound();
					startDoingStuff();
				}, startDoingStuff);
				*/
				startDoingStuff();
			});





			S.listen("importance", "change", function () {
				S.getId("positioner").value = "";
			});

			S.listen("syncData", "change", function () {
				if (M.server.user && this.checked) {
					mergeData = confirm("Merge this data with your account data?");
					if (mergeData) {  ////
						if (M.session.list().length > 0) {
							S.forEach(M.session.list(), function (key) {
								M.local.store(key, M.session.recall(key));
							});
						}
						deleteData = confirm("Delete account data not present here?");
					}
					refresh(true);
				} else {
					refresh();
				}
			});

			S.listen("useLocalStorage", "click", function () {
				recyclingBin = {};
				let settings = M[storagePlace].recall("/lists/start-up settings");
				if (S.getName("storagePlace", true).id == "useLocalStorage") {
					storagePlace = "local";
				} else {
					storagePlace = "session";
				}
				settings.storageType = storagePlace;
				M[storagePlace].store("/lists/start-up settings", settings);
			});

			S.listen("useSessionStorage", "click", function () {
				recyclingBin = {};
				let settings = M[storagePlace].recall("/lists/start-up settings");
				if (S.getName("storagePlace", true).id == "useLocalStorage") {
					storagePlace = "local";
				} else {
					storagePlace = "session";
				}
				settings.storageType = storagePlace;
				M[storagePlace].store("/lists/start-up settings", settings);
			});

			S.listen("defaultList", "change", function () {
				let settings = M[storagePlace].recall("/lists/start-up settings");
				settings.list = this.value;
				M[storagePlace].store("/lists/start-up settings", settings);
			});

			S.listen("soundVolume", "change", function () {
				/*
				if (noisemaker.playing && noisemaker.hertzChange != 0) {  // if the lateness alarm is constantly going off
					//// console.log("--------");
					//// console.log(noisemaker.playing);
					noisemaker.stop();
					//// console.log(noisemaker.playing);
					noisemaker.change("maxVolume", Number(this.value) / 100);
					//// console.log(noisemaker.playing);
					noisemaker.start();
					//// console.log(noisemaker.playing);
				} else {
					noisemaker.change("maxVolume", Number(this.value) / 100);
					noisemaker.play("a5---");
				}
				*/
				let settings = M[storagePlace].recall("/lists/start-up settings");
				settings.volume = Number(this.value);
				M[storagePlace].store("/lists/start-up settings", settings);
			});


			S.listen("showAdvancedSettings", "click", function () {
				S.makeDialog(advancedSettingsSection, "");
				S.getId("listTitle").value = decodeURIComponent(M[storagePlace].defaultLocation.split("/")[1]);
				S.getId("settingsSection").children[1].style.display = "none";
			});

			S.listen("listTitle", "change", function () {
				let oldTitle = M[storagePlace].defaultLocation.split("/")[1];
				let newTitle = encode(this.value.trim());
				M[storagePlace].move("/lists/" + oldTitle + "/", "/lists/" + newTitle + "/");
				M[storagePlace].defaultLocation = "lists/" + newTitle + "/items";
				if (M[storagePlace].recall("/lists/start-up settings").list == currentList) {
					let settings = M[storagePlace].recall("/lists/start-up settings");
					settings.list = newTitle;
					M[storagePlace].store("/lists/start-up settings", settings);
				}
				currentList = newTitle;
				refresh();
			});

			S.listen("listOrdering", "change", function () {
				M[storagePlace].store("../settings/ordering", this.value);
				refresh();
			});

			S.listen("dayThresholdSetter", "change", function () {
				if (this.value == Math.round(this.value)) {  // if the number is an integer
					M[storagePlace].store("../settings/threshold", this.value);
					refresh();
				}
			});

			S.listen("inspiringMessages", "click", function () {
				let settings = M.local.recall("/lists/start-up settings");
				settings.inspiration = this.checked;
				M[storagePlace].store("/lists/start-up settings", settings);
			});

			S.listen("procrastinator", "click", function () {  // puts off indefinite and continual items due immediately
				now = new Date();
				M[storagePlace].list().forEach(function (key) {
					let item = M[storagePlace].recall(key);
					if ((item.recurrence == "indefinite" || item.recurrence == "continual") && Number(item.time.split("~")[0]) <= now.getTime()) {
						if (item.recurrence == "indefinite" && Number(item.importance) < 4) {
							// puts lower-priority items further off into the future
							// randomly assigns exact times within certain tiers
							item.time = Math.round(now.getTime() + ((3.7 - Number(item.importance)) * 7 + Math.random() * 7 - 3.5) * 86400000) + "~";
							M[storagePlace].store(key, item);
						} else if (item.recurrence == "continual") {
							item.time = now.getTime() + Math.pow(6 - Number(item.importance), 2) * 100000000 + "~";  // This is half the normal time.
							M[storagePlace].store(key, item);
						}
					}
				});
				refresh();
			});

			S.listen("listDeletor", "click", function () {
				S.makeDialog("Are you sure you want to delete this list?", ["Yes", function () {
					setTimeout(function () {
						let shouldDelete = true;
						S.makeDialog('<span id="deletingMessage">Deleting list...</span>', ['<span id="deletingButton">Cancel</span>', function () {
							shouldDelete = false;
						}]);
						setTimeout(function () {
							if (shouldDelete) {
								S.forEach(M[storagePlace].list("../"), function (key) {
									M[storagePlace].forget("../" + key);
								});
								S.getId("deletingMessage").textContent = "List deleted.";
								S.getId("deletingButton").textContent = "Okay";
								if (M[storagePlace].recall("/lists/start-up settings").list != currentList) {
									currentList = M[storagePlace].recall("/lists/start-up settings").list;
									M[storagePlace].defaultLocation = "lists/" + currentList + "/items";
								} else {
									M[storagePlace].defaultLocation = "lists/Default/items";
									currentList = "Default";
									M[storagePlace].store("../settings/ordering", "dynamic");
									M[storagePlace].store("../settings/filter", []);
									let settings = M[storagePlace].recall("/lists/start-up settings");
									settings.list = "Default";
									M[storagePlace].store("/lists/start-up settings", settings);
								}
								refresh();
							}
						}, 3000);
					}, 0);
				}], "No");
			});

			S.listen("loadSampleList", "click", function () {
				recyclingBin = {};
				if (this.textContent.trim() == "Load sample list") {
					this.textContent = "Remove sample list";
					S.getId("useSessionStorage").checked = true;
					storagePlace = "session";
					if (M[storagePlace].recall("../settings/ordering") instanceof Error) {
						M[storagePlace].store("../settings/ordering", "dynamic");
					}
					S.forEach(sampleList, function (item) {
						let description = encode(item.description);
						delete item.description;
						M.session.store(description, item);
					});
				} else {
					S.forEach(M.session.list(), function (key) {
						M.session.forget(key);
					});
					S.getId("useLocalStorage").checked = true;
					storagePlace = "local";
					this.textContent = "Load sample list";
				}
				refresh();
			});

			S.listen("undelete", "click", function () {
				if (Object.keys(recyclingBin).length > 0) {  // if there are items in the recycling bin
					if (Object.keys(recyclingBin)[0].includes("/")) {  // if the storage locations had the whole path specified
						S.forEach(recyclingBin, function (value, key) {
							M[storagePlace].store("/lists/" + key, value);
						});
					} else {
						S.forEach(recyclingBin, function (value, key) {
							M[storagePlace].store(key, value);
						});
					}
					recyclingBin = {};
					refresh();
				}
			});

			S.listen("update", "click", function () {
				if (!this.disabled) {
					// displays a JSON backup of the data
					let backup = "{\n";
					S.forEach(M[storagePlace].list("/lists/"), function (key) {
						backup += '"/lists/' + key + '": ' + JSON.stringify(M[storagePlace].recall("/lists/" + key)) + ",\n";
					});
					backup = backup.slice(0, -2) + "\n}";
					S.getId("list").innerHTML = "<pre>" + backup + "</pre>";
				}
				//// do something with day thresholds (add them uniformly somehow)
			});


			S.listen("filterCheckbox", "click", function () {
				let settings = M[storagePlace].recall("/lists/start-up settings");
				if (this.checked) {
					S.getId("filterSection").style.display = "inline-table";
					if (settings.hide.includes("filter")) {
						settings.hide.splice(settings.hide.indexOf("filter"), 1);
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				} else {
					S.getId("filterSection").style.display = "none";
					if (!settings.hide.includes("filter")) {
						settings.hide.push("filter");
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				}
			});

			S.listen("notificationsCheckbox", "click", function () {
				let settings = M[storagePlace].recall("/lists/start-up settings");
				if (this.checked) {
					S.getId("notificationsSection").style.display = "inline-table";
					if (settings.hide.includes("notifications")) {
						settings.hide.splice(settings.hide.indexOf("notifications"), 1);
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				} else {
					S.getId("notificationsSection").style.display = "none";
					if (!settings.hide.includes("notifications")) {
						settings.hide.push("notifications");
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				}
			});

			S.listen("listsCheckbox", "click", function () {
				let settings = M[storagePlace].recall("/lists/start-up settings");
				if (this.checked) {
					S.getId("listsSection").style.display = "inline-table";
					if (settings.hide.includes("lists")) {
						settings.hide.splice(settings.hide.indexOf("lists"), 1);
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				} else {
					S.getId("listsSection").style.display = "none";
					if (!settings.hide.includes("lists")) {
						settings.hide.push("lists");
						M[storagePlace].store("/lists/start-up settings", settings);
					}
				}
			});

			S.listen("listMaker", "click", function () {
				let title = encode(S.getId("newListTitle").value.trim());
				if (title != "") {
					M[storagePlace].store("/lists/" + title + "/settings/lastUpdated", now.getTime());
					M[storagePlace].store("/lists/" + title + "/settings/ordering", "dynamic");
					M[storagePlace].store("/lists/" + title + "/settings/filter", []);
					M[storagePlace].store("/lists/" + title + "/lastUpdated", now.getTime());
					S.getId("newListTitle").value = "";
					S.getId("listsSection").children[1].style.display = "none";
					M[storagePlace].defaultLocation = "lists/" + title + "/items";
					currentList = title;
					recyclingBin = {};
					refresh();
					S.getId("showAdvancedSettings").click();
				}
			});
		</script>
		<link rel="stylesheet" href="https://epicenterprograms.github.io/standards/formatting/foundation.css">
		<!--
		<link rel="stylesheet" href="file:///C:/Users/rtben/Documents/GitHub/standards/formatting/foundation.css">
		-->
		<style>
			main {
				margin-top: 0em;
			}
			nav.top-nav {
				margin: auto;
				width: 90%;
			}
			nav.top-nav td {
				padding: 0em;
			}
			nav.top-nav label {
				white-space: nowrap;
			}
			nav.top-nav div.drop-down div {
				padding: .5em;
			}
			nav.top-nav div.drop-down table {
				margin: 0rem;
			}
			.list-item {
				margin: .5em 0em;
			}
			.block {
				display: block;
				margin: 1em auto;
			}
			.subtle {
				all: initial;
				display: block;
				margin: auto;
				border: none;
				padding: .2em;
				background: none;
				font-family: serif;
				font-size: 1em;
				color: black;
			}
			.subtle::before {
				display: none;
			}
			.subtle::after {
				display: none;
			}
			.subtle:hover {
				background: rgba(255, 255, 255, .5);
				font-weight: bold;
			}
			.icon {
				margin-left: .5em;
				height: 1em;
			}
			#pastDueNotifier {
				display: none;
				position: relative;
				top: .25em;
				z-index: 1;
				border: 1px solid black;
				border-radius: .75em;
				padding: 0em;
				width: 1.25em;
				height: 1.25em;
				background: red;
				font-size: .75em;
				color: white;
				overflow: hidden;
				line-height: 1.15em;
			}
			#dynamicEditor {
				display: block;
				position: static;
				padding: 0rem;
			}
			#staticEditor {
				display: none;
				position: static;
				padding: 0rem;
			}
			#randomEditor {
				display: none;
				position: static;
				padding: 0rem;
			}
			#pastDueItems {
				display: inline-block;
				position: static;
				padding: .15em 0em 0em;
				height: 1em;
				overflow: hidden;
			}
			#dueTodayItems {
				display: inline-block;
				position: static;
				padding: .15em 0em 0em;
				height: 1em;
				overflow: hidden;
			}
			#importanceFilter {
				display: table;
				position: static;
			}
			#labelContainer {
				display: inline-block;
				position: static;
				max-height: 7rem;
				padding: 0rem;
			}
			#labelContainer div {
				display: inline-block;
				position: static;
				padding: 0rem;
			}
			#listList {
				display: inline-block;
				position: static;
				max-height: 16.5em;
			}

			@media (max-width: 1000px) {
				nav.top-nav {
					width: 100%;
				}
			}
		</style>
	</head>
	<body>
		<h1 class="main-title">
			Lists
		</h1>
		<div class="user-section">
			<button id="signIn">
				Log in
			</button>
			<button id="signUp">
				Register
			</button>
			<button id="userSettings">
				Settings
			</button>
			<button id="signOut">
				Log out
			</button>
		</div>
		<nav class="top-nav manual">
			<div class="drop-down" tabindex="0" id="settingsSection">
				<div>
					Settings
				</div>
				<div>
					<table class="organizational">
						<tr style="display:none">
							<td><input type="checkbox" id="syncData"></td>
							<td><label for="syncData">Sync data with your account when possible</label></td>
						</tr>
						<tr>
							<td>
								<button onclick="mergeInformation(true)" disabled>
									Copy local to server
								</button>
							</td>
							<td>
								<button onclick="mergeInformation()" disabled>
									Copy server to local
								</button>
							</td>
						</tr>
						<tr>
							<td>
								Store indefinitely
							</td>
							<td>
								Store temporarily
							</td>
						</tr>
						<tr>
							<td>
								<input type="radio" name="storagePlace" id="useLocalStorage" checked>
							</td>
							<td>
								<input type="radio" name="storagePlace" id="useSessionStorage">
							</td>
						</tr>
					</table>
					<br>
					<h4 style="margin:.25em">
						Volume
					</h4>
					<input type="range" id="soundVolume" value="100">
					<h4 style="margin:.25em">
						Default list
					</h4>
					<select id="defaultList"></select>
					<h4 style="margin:.25em">
						Sections to show
					</h4>
					<div class="list" style="display:table; position:static;">
						<input type="checkbox" id="filterCheckbox" checked>
						<label for="filterCheckbox">Filter</label><br>
						<input type="checkbox" id="notificationsCheckbox" checked>
						<label for="notificationsCheckbox">Notifications</label><br>
						<input type="checkbox" id="listsCheckbox" checked>
						<label for="notificationsCheckbox">Lists</label>
					</div>
					<br>
					<button id="showAdvancedSettings">
						Show advanced settings
					</button>
					<div id="advancedSettings">
						<h4 style="margin:.25em">
							List title
						</h4>
						<input type="text" id="listTitle">
						<h4 style="margin:.25em">
							Type of ordering
						</h4>
						<select id="listOrdering">
							<option value="dynamic" selected>
								Dynamic
							</option>
							<option value="static">
								Static
							</option>
							<option value="random">
								Random
							</option>
						</select>
						<h4 style="margin:.25em">
							Day threshold
						</h4>
						<input type="text" id="dayThresholdSetter" value="7" style="width:1.5em">&thinsp;:00
						<br>
						<input type="checkbox" id="inspiringMessages">
						<label for="inspiringMessages">say inspiring messages</label>
						<br>
						<button id="procrastinator">
							Postpone items
						</button>
						<button id="listDeletor">
							Delete list
						</button>
						<br>
						<button id="loadSampleList">
							Load sample list
						</button>
						<button id="undelete">
							Undelete items
						</button>
						<br>
						<button id="update">
							Reprocess
						</button>
					</div>
				</div>
			</div>
			<div class="drop-down" tabindex="0" id="editorSection">
				<div>
					Editor
				</div>
				<div>
					<input type="text" class="block" id="description" placeholder="Description" style="margin-top:.5em">
					<input type="text" class="block" id="labels" placeholder="Labels">
					<div class="list" id="labelContainer" style="display:none"></div>
					<select class="block" id="importance" style="margin-bottom:0rem">
						<option value="" disabled selected>
							Importance
						</option>
						<option value="5">
							5 (highest)
						</option>
						<option value="4">
							4
						</option>
						<option value="3">
							3
						</option>
						<option value="2">
							2
						</option>
						<option value="1">
							1 (lowest)
						</option>
					</select>
					<div id="dynamicEditor">
						<select class="block" id="recurrence">
							<option value="" disabled selected>
								Recurrence
							</option>
							<option value="continual">
								Continual
							</option>
							<option value="indefinite">
								Indefinite
							</option>
							<option value="once">
								One time
							</option>
							<option value="monthly">
								Monthly
							</option>
							<option value="weekly">
								Weekly
							</option>
							<option value="daily">
								Daily
							</option>
						</select>
						<section id="indefinite" style="display:none">
							<select id="timeframe">
								<option value="" disabled selected>
									Timeframe
								</option>
								<option value="immediately">
									Immediately
								</option>
								<option value="soon">
									Soon
								</option>
								<option value="later">
									Later
								</option>
								<option value="aWhile">
									In a while
								</option>
								<option value="somePoint">
									At some point
								</option>
								<option value="same" name="same" disabled>
									Same
								</option>
							</select>
						</section>
						<section id="once" style="display:none">
							<input type="date" id="fullDate" placeholder="yyyy-mm-dd">
						</section>
						<section id="monthly" style="display:none">
							<input type="text" id="day" placeholder="Day of the month">
						</section>
						<section id="weekly" class="list" style="display:none">
							<input type="checkbox" id="monday">
							<label for="monday">Monday</label>
							<br>
							<input type="checkbox" id="tuesday">
							<label for="tuesday">Tuesday</label>
							<br>
							<input type="checkbox" id="wednesday">
							<label for="wednesday">Wednesday</label>
							<br>
							<input type="checkbox" id="thursday">
							<label for="thursday">Thursday</label>
							<br>
							<input type="checkbox" id="friday">
							<label for="friday">Friday</label>
							<br>
							<input type="checkbox" id="saturday">
							<label for="saturday">Saturday</label>
							<br>
							<input type="checkbox" id="sunday">
							<label for="sunday">Sunday</label>
						</section>
						<section id="timeSection" style="display:none">
							<input type="text" id="time" placeholder="Time (hour:minute)">
						</section>
						<div>
							<button onclick="includeDynamicItem()">
								Add to list
							</button>
							<button onclick="remove()">
								Remove
							</button>
						</div>
					</div>
					<div id="staticEditor">
						<input type="text" class="block" id="positioner" placeholder="position">
						<br>
						<div>
							<button onclick="includeStaticItem()">
								Add to list
							</button>
							<button onclick="remove()">
								Remove
							</button>
						</div>
					</div>
					<div id="randomEditor">
						<div>
							<button onclick="includeRandomItem()">
								Add to list
							</button>
							<button onclick="remove()">
								Remove
							</button>
						</div>
					</div>
					<button onclick="S.makeDialog(advancedEditorSection, 'Done')">
						Advanced
					</button>
					<button onclick="cancel()">
						Cancel
					</button>
					<div id="advancedEditor">
						<textarea id="elaboration" placeholder="Elaboration"></textarea>
						<h4 style="margin:.25em">
							Difficulty
						</h4>
						<select id="difficulty">
							<option value="5">
								5 (highest)
							</option>
							<option value="4">
								4
							</option>
							<option value="3" selected>
								3
							</option>
							<option value="2">
								2
							</option>
							<option value="1">
								1 (lowest)
							</option>
						</select>
						<h4 style="margin:.25em">
							Ideal due time
						</h4>
						<input type="date" placeholder="yyyy-mm-dd"><br>
						<input type="text" placeholder="00:00 am/pm">
					</div>
				</div>
			</div>
			<div class="drop-down" tabindex="0" id="filterSection">
				<div>
					Filter
				</div>
				<div>
					<section id="numberOfFilteredItems"></section>
					<div class="list" id="importanceFilter">
						<input type="checkbox"><label>1</label><br>
						<input type="checkbox"><label>2</label><br>
						<input type="checkbox"><label>3</label><br>
						<input type="checkbox"><label>4</label><br>
						<input type="checkbox"><label>5</label>
					</div><br>
					<input type="text" id="listFilter" placeholder="Filter items">
				</div>
			</div>
			<div class="drop-down" tabindex="0" id="notificationsSection">
				<div>
					Notifications
					<div id="pastDueNotifier"></div>
				</div>
				<div>
					There are
					<div id="pastDueItems">0</div>
					past-due items.
					<br>
					There are
					<div id="dueTodayItems">0</div>
					items due today.
				</div>
			</div>
			<div class="drop-down" tabindex="0" id="listsSection">
				<div>
					Lists
				</div>
				<div>
					<div id="listList"></div>
					<br>
					<input type="text" id="newListTitle" placeholder="New list">
					<br>
					<button id="listMaker">
						Create
					</button>
				</div>
			</div>
		</nav>
		<main>
			<div id="list" class="list"></div>
		</main>
	</body>
</html>
